<?xml version="1.0" encoding="utf-8"?>
<!-- origin: https://raw.githubusercontent.com/Jaykul/Profile/master/Types.ps1xml -->
<Types>
    <Type>
        <Name>System.Byte[]</Name>
        <Members>
            <ScriptProperty>
                <Name>Hex</Name>
                <GetScriptBlock>
                    $this | % {Write-Output $([String]::Format("{0:X}",$_))}
                </GetScriptBlock>
            </ScriptProperty>
            <ScriptMethod>
                <Name>ToBinaryNotation</Name>
                <Script>
                    $this | Foreach-Object -begin {$OFS = ''} -process {
                        $DecimalByte = $_
                        $buffer = [byte[]]::new(8)
                        $bufferLength = $buffer.Length - 1

                        while ( $bufferLength -ne 0 ) {
                            $Q = $DecimalByte % 2
                            $buffer[$bufferLength--] = $Q
                            $DecimalByte = [Math]::Floor($DecimalByte * .5)
                        }
                        Write-Output $("$buffer".Substring(0, 4) + " " + "$buffer".Substring(4))
                    }
                    
                </Script>
            </ScriptMethod>
            <ScriptMethod>
                <Name>ToUnicode</Name>
                <Script>
                    $this | Foreach-Object -begin {
                        [string[]]$HexDecimalTable = '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
                    } -process {
                        $Point = $_
                        # BMP (Basic Multilingual Plane) only.
                        if ($Point -lt 65536) {
                            # $Subplane represents blocks of 4096 code points
                            $Subplane = $HexDecimalTable[[Math]::Floor($Point / [Math]::Pow(16, 3) % 16)]
                            # $256Block represents blocks of 256 code points
                            $256Block = $HexDecimalTable[[Math]::Floor($Point / [Math]::Pow(16, 2) % 16)]
                            $PointRow = $HexDecimalTable[[Math]::Floor($Point / 16) % 16]
                            $PointCol = $HexDecimalTable[$Point % 16]
                            $Unicode = "$Subplane$256Block$PointRow$PointCol".Insert(0, 'U+')
                        }
                        else {
                            $Unicode = "U+FFFF"
                        }
                        Write-Output $Unicode
                    }
                </Script>
            </ScriptMethod>
        </Members>
    </Type>
    <Type>
        <Name>Microsoft.PowerShell.Commands.MemberDefinition</Name>
        <Members>
            <ScriptProperty>
                <Name>HelpLink</Name>
                <GetScriptBlock>"http://msdn2.microsoft.com/library/$($this.typename).$($this.name).aspx"</GetScriptBlock>
            </ScriptProperty>
            <ScriptMethod>
                <Name>OpenHelpLink</Name>
                <Script>
                    Start-Process $this.HelpLink
                </Script>
            </ScriptMethod>
        </Members>
    </Type>
    <Type>
        <Name>System.String</Name>
        <Members>
            <ScriptMethod>
                <Name>ToBase64</Name>
                <Script>
                    [System.Convert]::ToBase64String([System.Text.Encoding]::UTF8.GetBytes($this))
                </Script>
            </ScriptMethod>
            <ScriptMethod>
                <Name>FromBase64</Name>
                <Script>
                    [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($this))
                </Script>
            </ScriptMethod>
            <ScriptMethod>
                <Name>MatchCount</Name>
                <Script>
                    [regex]::Matches($this, $args[0]).Count
                </Script>
            </ScriptMethod>
        </Members>
    </Type>
    <Type>
        <Name>System.Security.SecureString</Name>
        <Members>
            <ScriptMethod>
                <Name>ToPlainText</Name>
                <Script>
                    $plaintext = ""
                    try {
                        $BSTR = [System.Runtime.InteropServices.marshal]::SecureStringToBSTR($this);
                        $plaintext = [System.Runtime.InteropServices.marshal]::PtrToStringAuto($BSTR);
                    } finally {
                        if($BSTR -ne [IntPtr]::Zero) {
                            [System.Runtime.InteropServices.Marshal]::ZeroFreeBSTR($BSTR);
                        }
                    }
                    Write-Output $plaintext
                </Script>
            </ScriptMethod>
        </Members>
    </Type>
</Types>